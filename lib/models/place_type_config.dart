import 'package:flutter/material.dart';
import 'package:mongo_dart/mongo_dart.dart' as mongo; // Keep for types if needed, or remove if unused in interface
import '../services/database/database_service.dart'; // Updated
import '../services/auth_service.dart';

class PlaceTypeConfig {
// ... [Class properties unchanged] ...
  final String id;
  final String name;
  final String label;
  final IconData icon;
  final int points;
  final Color color;
  final bool isActive;
  final int order;
  final DateTime createdAt;
  final DateTime updatedAt;
  final String? createdBy;
  final String? updatedBy;

  const PlaceTypeConfig({
    required this.id,
    required this.name,
    required this.label,
    required this.icon,
    required this.points,
    required this.color,
    this.isActive = true,
    required this.order,
    required this.createdAt,
    required this.updatedAt,
    this.createdBy,
    this.updatedBy,
  });

  PlaceTypeConfig copyWith({
    String? id,
    String? name,
    String? label,
    IconData? icon,
    int? points,
    Color? color,
    bool? isActive,
    int? order,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? createdBy,
    String? updatedBy,
  }) => PlaceTypeConfig(
    id: id ?? this.id,
    name: name ?? this.name,
    label: label ?? this.label,
    icon: icon ?? this.icon,
    points: points ?? this.points,
    color: color ?? this.color,
    isActive: isActive ?? this.isActive,
    order: order ?? this.order,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    createdBy: createdBy ?? this.createdBy,
    updatedBy: updatedBy ?? this.updatedBy,
  );

  Map<String, dynamic> toMap() => {
    'id': id,
    'name': name,
    'label': label,
    'icon': icon.codePoint,
    'points': points,
    'color': color.value,
    'isActive': isActive,
    'order': order,
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt.toIso8601String(),
    'createdBy': createdBy,
    'updatedBy': updatedBy,
  };

  factory PlaceTypeConfig.fromMap(Map<String, dynamic> map) {
    // Default icon and color mappings
    final iconMap = {
      'PEAK': Icons.terrain,
      'TOWER': Icons.attractions,
      'TREE': Icons.park,
      'OTHER': Icons.place_outlined,
    };
    
    final colorMap = {
      'PEAK': Colors.orange,
      'TOWER': Colors.blue,
      'TREE': Colors.green,
      'OTHER': Colors.grey,
    };

    // Helper for safe icon loading if stored as int or mapped
    IconData getIcon() {
        if (map['icon'] is int) return IconData(map['icon'], fontFamily: 'MaterialIcons');
        return iconMap[map['name']] ?? Icons.place_outlined;
    }

    return PlaceTypeConfig(
      id: map['id']?.toString() ?? '',
      name: map['name']?.toString() ?? '',
      label: map['label']?.toString() ?? '',
      icon: getIcon(),
      points: safeIntFromMap(map['points']),
      color: Color(safeIntFromMap(map['color']) ?? Colors.grey.value),
      isActive: map['isActive'] != false,
      order: safeIntFromMap(map['order']),
      createdAt: DateTime.tryParse(map['createdAt']?.toString() ?? '') ?? DateTime.now(),
      updatedAt: DateTime.tryParse(map['updatedAt']?.toString() ?? '') ?? DateTime.now(),
      createdBy: map['createdBy']?.toString(),
      updatedBy: map['updatedBy']?.toString(),
    );
  }

  static int safeIntFromMap(dynamic value) {
    if (value == null) return 0;
    if (value is int) return value;
    if (value is num) return value.toInt();
    if (value.toString().startsWith('Int64')) {
       // Handle Int64 specifically if it comes as a string representation or similar object
       // But often Int64 just needs .toInt() if it's the fixnum type.
       // Since we don't import fixnum here, we rely on dynamic or toString parsing if needed.
       // However, often simply value.toInt() works if it acts like a number.
       // Let's try to parse string reference if it's really an object.
       return int.tryParse(value.toString()) ?? 0;
    }
    if (value is String) {
      final parsed = int.tryParse(value);
      return parsed ?? 0;
    }
    // Fallback for Int64 which might not be num but has toInt
    try {
      return (value as dynamic).toInt();
    } catch (_) {
      return 0;
    }
  }
}

class PlaceTypeConfigService {
  static final PlaceTypeConfigService _instance = PlaceTypeConfigService._internal();
  factory PlaceTypeConfigService() => _instance;
  PlaceTypeConfigService._internal();

  final DatabaseService _dbService = DatabaseService();
  static const String _collection = 'place_type_configs';

  Future<List<PlaceTypeConfig>> getPlaceTypeConfigs() async {
    return _dbService.execute((db) async {
      final collection = db.collection(_collection);
      final configs = await collection.find().toList();
      
      if (configs.isEmpty) {
        await _createDefaultPlaceTypeConfigs();
        final refreshed = await collection.find().toList();
        configs.addAll(refreshed);
      }
      
      configs.sort((a, b) => PlaceTypeConfig.safeIntFromMap(a['order']).compareTo(PlaceTypeConfig.safeIntFromMap(b['order'])));
      final result = configs.map((doc) => PlaceTypeConfig.fromMap(doc)).toList();
      return result.where((config) => config.isActive).toList();
    }).catchError((e) {
      print('❌ Error loading place type configs: $e');
      return <PlaceTypeConfig>[];
    });
  }

  Future<void> _createDefaultPlaceTypeConfigs() async {
    return _dbService.execute((db) async {
      final collection = db.collection(_collection);
      final now = DateTime.now();
      final defaultConfigs = [
        PlaceTypeConfig(
          id: 'PEAK',
          name: 'PEAK',
          label: 'Vrchol',
          icon: Icons.terrain,
          points: 1,
          color: Colors.orange,
          order: 0,
          createdAt: now,
          updatedAt: now,
        ),
        PlaceTypeConfig(
          id: 'TOWER',
          name: 'TOWER',
          label: 'Rozhledna',
          icon: Icons.attractions,
          points: 1,
          color: Colors.blue,
          order: 1,
          createdAt: now,
          updatedAt: now,
        ),
        PlaceTypeConfig(
          id: 'TREE',
          name: 'TREE',
          label: 'Památný strom',
          icon: Icons.park,
          points: 1,
          color: Colors.green,
          order: 2,
          createdAt: now,
          updatedAt: now,
        ),
        PlaceTypeConfig(
          id: 'OTHER',
          name: 'OTHER',
          label: 'Jiné',
          icon: Icons.place_outlined,
          points: 0,
          color: Colors.grey,
          order: 3,
          createdAt: now,
          updatedAt: now,
        ),
      ];

      final configsToSave = defaultConfigs.map((config) => config.toMap()).toList();
      await collection.insertAll(configsToSave);
      print('✅ Default place type configs created successfully');
    }).catchError((e) {
      print('❌ Error creating default configs: $e');
    });
  }

  Future<bool> savePlaceTypeConfigs(List<PlaceTypeConfig> configs) async {
    return _dbService.execute((db) async {
      final collection = db.collection(_collection);
      await collection.deleteMany({});
      final currentUser = AuthService.currentUser?.id;
      final now = DateTime.now();
      
      final configsToSave = configs.map((config) {
        return config.copyWith(updatedAt: now, updatedBy: currentUser).toMap();
      }).toList();

      if (configsToSave.isNotEmpty) {
        await collection.insertAll(configsToSave);
      }
      return true;
    }).catchError((e) {
      print('❌ Error saving place type configs: $e');
      return false;
    });
  }

  Future<bool> updatePlaceTypeConfig(PlaceTypeConfig config) async {
    return _dbService.execute((db) async {
      final collection = db.collection(_collection);
      final currentUser = AuthService.currentUser?.id;
      final now = DateTime.now();
      
      final configToUpdate = config.copyWith(updatedAt: now, updatedBy: currentUser);
      final result = await collection.replaceOne({'id': config.id}, configToUpdate.toMap());
      return result.isSuccess;
    }).catchError((e) {
      print('❌ Error updating place type config: $e');
      return false;
    });
  }

  Future<bool> reorderPlaceTypeConfigs(List<String> configIds) async {
    return _dbService.execute((db) async {
      final collection = db.collection(_collection);
      for (int i = 0; i < configIds.length; i++) {
        await collection.updateOne(
          {'id': configIds[i]},
          {'\$set': {'order': i}},
        );
      }
      return true;
    }).catchError((e) {
      print('❌ Error reordering place type configs: $e');
      return false;
    });
  }

  Future<bool> deletePlaceTypeConfig(String configId) async {
    return _dbService.execute((db) async {
      final collection = db.collection(_collection);
      final result = await collection.deleteOne({'id': configId});
      return result.isSuccess;
    }).catchError((e) {
      print('❌ Error deleting place type config: $e');
      return false;
    });
  }

  Future<bool> updatePlaceTypeStatus(String configId, bool isActive) async {
    return _dbService.execute((db) async {
      final collection = db.collection(_collection);
      final result = await collection.updateOne(
        {'id': configId},
        {'\$set': {'isActive': isActive}},
      );
      return result.isSuccess;
    }).catchError((e) {
      print('❌ Error updating place type config status: $e');
      return false;
    });
  }

  Future<bool> reorderPlaceTypes(List<String> configIds) async {
    return await reorderPlaceTypeConfigs(configIds);
  }
}
